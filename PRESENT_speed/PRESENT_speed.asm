/*
 * PRESENT_cipher_speed.asm
 * A speed-oriented implementation of the PRESENT cipher on Atmel AVR microcontroller [ATtiny45]
 * [original paper "PRESENT: AN Ultral Lightweight Block Cipher" by A. Bogdanov et al.]
 *
 *  Created: 17-Feb-13 2:16:47 PM
 *   Authors:
 *		Aram Verstegen, aram.verstegen@gmail.com
 *		Kostas Papagiannopoulos, kostaspap88@gmail.com		  
 *		Radboud University Nijmegen, Kerckhoff's Institute
 *
 *		Speed Optimizations:
 *		<list to be completed>
 */ 

 .include "tn45def.inc"



 
/* Start at a position high in memory, make sure that code doesn't reach it. */
.org 0x0300

/* 
 * Use lookup tables that combine the cipher's SBox and Player.
 *	Originally created and developed by Bo Zhu and Zheng Gong, bo.zhu@uwaterloo.ca, cis.gong@gmail.com
 * [http://cis.sjtu.edu.cn/index.php/Software_Implementation_of_Block_Cipher_PRESENT_for_8-Bit_Platforms]
 */

/* Care: Each .db directive must use an EVEN number (namely 8) of arguments s.t. we don't waste memory
   [.db 0xFF stores 1 byte in 1 word, so we prefer .db 0xFF 0xFF, i.e. 2 bytes in 1 word] */

sbox_pmt_3:
.db	0xF0, 0xB1, 0xB4, 0xE5, 0xE1, 0xA0, 0xE4, 0xF1, 0xA5, 0xF4, 0xF5, 0xE0, 0xB0, 0xB5, 0xA1, 0xA4 
.db	0x72, 0x33, 0x36, 0x67, 0x63, 0x22, 0x66, 0x73, 0x27, 0x76, 0x77, 0x62, 0x32, 0x37, 0x23, 0x26 
.db	0x78, 0x39, 0x3C, 0x6D, 0x69, 0x28, 0x6C, 0x79, 0x2D, 0x7C, 0x7D, 0x68, 0x38, 0x3D, 0x29, 0x2C 
.db	0xDA, 0x9B, 0x9E, 0xCF, 0xCB, 0x8A, 0xCE, 0xDB, 0x8F, 0xDE, 0xDF, 0xCA, 0x9A, 0x9F, 0x8B, 0x8E 
.db	0xD2, 0x93, 0x96, 0xC7, 0xC3, 0x82, 0xC6, 0xD3, 0x87, 0xD6, 0xD7, 0xC2, 0x92, 0x97, 0x83, 0x86
.db	0x50, 0x11, 0x14, 0x45, 0x41, 0x00, 0x44, 0x51, 0x05, 0x54, 0x55, 0x40, 0x10, 0x15, 0x01, 0x04
.db	0xD8, 0x99, 0x9C, 0xCD, 0xC9, 0x88, 0xCC, 0xD9, 0x8D, 0xDC, 0xDD, 0xC8, 0x98, 0x9D, 0x89, 0x8C
.db	0xF2, 0xB3, 0xB6, 0xE7, 0xE3, 0xA2, 0xE6, 0xF3, 0xA7, 0xF6, 0xF7, 0xE2, 0xB2, 0xB7, 0xA3, 0xA6
.db	0x5A, 0x1B, 0x1E, 0x4F, 0x4B, 0x0A, 0x4E, 0x5B, 0x0F, 0x5E, 0x5F, 0x4A, 0x1A, 0x1F, 0x0B, 0x0E
.db	0xF8, 0xB9, 0xBC, 0xED, 0xE9, 0xA8, 0xEC, 0xF9, 0xAD, 0xFC, 0xFD, 0xE8, 0xB8, 0xBD, 0xA9, 0xAC
.db	0xFA, 0xBB, 0xBE, 0xEF, 0xEB, 0xAA, 0xEE, 0xFB, 0xAF, 0xFE, 0xFF, 0xEA, 0xBA, 0xBF, 0xAB, 0xAE 
.db	0xD0, 0x91, 0x94, 0xC5, 0xC1, 0x80, 0xC4, 0xD1, 0x85, 0xD4, 0xD5, 0xC0, 0x90, 0x95, 0x81, 0x84 
.db	0x70, 0x31, 0x34, 0x65, 0x61, 0x20, 0x64, 0x71, 0x25, 0x74, 0x75, 0x60, 0x30, 0x35, 0x21, 0x24 
.db	0x7A, 0x3B, 0x3E, 0x6F, 0x6B, 0x2A, 0x6E, 0x7B, 0x2F, 0x7E, 0x7F, 0x6A, 0x3A, 0x3F, 0x2B, 0x2E 
.db	0x52, 0x13, 0x16, 0x47, 0x43, 0x02, 0x46, 0x53, 0x07, 0x56, 0x57, 0x42, 0x12, 0x17, 0x03, 0x06 
.db	0x58, 0x19, 0x1C, 0x4D, 0x49, 0x08, 0x4C, 0x59, 0x0D, 0x5C, 0x5D, 0x48, 0x18, 0x1D, 0x09, 0x0C

sbox_pmt_2:
.db	0x3C, 0x6C, 0x2D, 0x79, 0x78, 0x28, 0x39, 0x7C, 0x69, 0x3D, 0x7D, 0x38, 0x2C, 0x6D, 0x68, 0x29
.db	0x9C, 0xCC, 0x8D, 0xD9, 0xD8, 0x88, 0x99, 0xDC, 0xC9, 0x9D, 0xDD, 0x98, 0x8C, 0xCD, 0xC8, 0x89 
.db	0x1E, 0x4E, 0x0F, 0x5B, 0x5A, 0x0A, 0x1B, 0x5E, 0x4B, 0x1F, 0x5F, 0x1A, 0x0E, 0x4F, 0x4A, 0x0B 
.db	0xB6, 0xE6, 0xA7, 0xF3, 0xF2, 0xA2, 0xB3, 0xF6, 0xE3, 0xB7, 0xF7, 0xB2, 0xA6, 0xE7, 0xE2, 0xA3 
.db	0xB4, 0xE4, 0xA5, 0xF1, 0xF0, 0xA0, 0xB1, 0xF4, 0xE1, 0xB5, 0xF5, 0xB0, 0xA4, 0xE5, 0xE0, 0xA1 
.db	0x14, 0x44, 0x05, 0x51, 0x50, 0x00, 0x11, 0x54, 0x41, 0x15, 0x55, 0x10, 0x04, 0x45, 0x40, 0x01 
.db	0x36, 0x66, 0x27, 0x73, 0x72, 0x22, 0x33, 0x76, 0x63, 0x37, 0x77, 0x32, 0x26, 0x67, 0x62, 0x23 
.db	0xBC, 0xEC, 0xAD, 0xF9, 0xF8, 0xA8, 0xB9, 0xFC, 0xE9, 0xBD, 0xFD, 0xB8, 0xAC, 0xED, 0xE8, 0xA9 
.db	0x96, 0xC6, 0x87, 0xD3, 0xD2, 0x82, 0x93, 0xD6, 0xC3, 0x97, 0xD7, 0x92, 0x86, 0xC7, 0xC2, 0x83 
.db	0x3E, 0x6E, 0x2F, 0x7B, 0x7A, 0x2A, 0x3B, 0x7E, 0x6B, 0x3F, 0x7F, 0x3A, 0x2E, 0x6F, 0x6A, 0x2B 
.db	0xBE, 0xEE, 0xAF, 0xFB, 0xFA, 0xAA, 0xBB, 0xFE, 0xEB, 0xBF, 0xFF, 0xBA, 0xAE, 0xEF, 0xEA, 0xAB 
.db	0x34, 0x64, 0x25, 0x71, 0x70, 0x20, 0x31, 0x74, 0x61, 0x35, 0x75, 0x30, 0x24, 0x65, 0x60, 0x21 
.db	0x1C, 0x4C, 0x0D, 0x59, 0x58, 0x08, 0x19, 0x5C, 0x49, 0x1D, 0x5D, 0x18, 0x0C, 0x4D, 0x48, 0x09 
.db	0x9E, 0xCE, 0x8F, 0xDB, 0xDA, 0x8A, 0x9B, 0xDE, 0xCB, 0x9F, 0xDF, 0x9A, 0x8E, 0xCF, 0xCA, 0x8B 
.db	0x94, 0xC4, 0x85, 0xD1, 0xD0, 0x80, 0x91, 0xD4, 0xC1, 0x95, 0xD5, 0x90, 0x84, 0xC5, 0xC0, 0x81 
.db	0x16, 0x46, 0x07, 0x53, 0x52, 0x02, 0x13, 0x56, 0x43, 0x17, 0x57, 0x12, 0x06, 0x47, 0x42, 0x03

sbox_pmt_1:
.db	0x0F, 0x1B, 0x4B, 0x5E, 0x1E, 0x0A, 0x4E, 0x1F, 0x5A, 0x4F, 0x5F, 0x0E, 0x0B, 0x5B, 0x1A, 0x4A
.db	0x27, 0x33, 0x63, 0x76, 0x36, 0x22, 0x66, 0x37, 0x72, 0x67, 0x77, 0x26, 0x23, 0x73, 0x32, 0x62 
.db	0x87, 0x93, 0xC3, 0xD6, 0x96, 0x82, 0xC6, 0x97, 0xD2, 0xC7, 0xD7, 0x86, 0x83, 0xD3, 0x92, 0xC2 
.db	0xAD, 0xB9, 0xE9, 0xFC, 0xBC, 0xA8, 0xEC, 0xBD, 0xF8, 0xED, 0xFD, 0xAC, 0xA9, 0xF9, 0xB8, 0xE8 
.db	0x2D, 0x39, 0x69, 0x7C, 0x3C, 0x28, 0x6C, 0x3D, 0x78, 0x6D, 0x7D, 0x2C, 0x29, 0x79, 0x38, 0x68 
.db	0x05, 0x11, 0x41, 0x54, 0x14, 0x00, 0x44, 0x15, 0x50, 0x45, 0x55, 0x04, 0x01, 0x51, 0x10, 0x40 
.db	0x8D, 0x99, 0xC9, 0xDC, 0x9C, 0x88, 0xCC, 0x9D, 0xD8, 0xCD, 0xDD, 0x8C, 0x89, 0xD9, 0x98, 0xC8 
.db	0x2F, 0x3B, 0x6B, 0x7E, 0x3E, 0x2A, 0x6E, 0x3F, 0x7A, 0x6F, 0x7F, 0x2E, 0x2B, 0x7B, 0x3A, 0x6A 
.db	0xA5, 0xB1, 0xE1, 0xF4, 0xB4, 0xA0, 0xE4, 0xB5, 0xF0, 0xE5, 0xF5, 0xA4, 0xA1, 0xF1, 0xB0, 0xE0 
.db	0x8F, 0x9B, 0xCB, 0xDE, 0x9E, 0x8A, 0xCE, 0x9F, 0xDA, 0xCF, 0xDF, 0x8E, 0x8B, 0xDB, 0x9A, 0xCA 
.db	0xAF, 0xBB, 0xEB, 0xFE, 0xBE, 0xAA, 0xEE, 0xBF, 0xFA, 0xEF, 0xFF, 0xAE, 0xAB, 0xFB, 0xBA, 0xEA 
.db	0x0D, 0x19, 0x49, 0x5C, 0x1C, 0x08, 0x4C, 0x1D, 0x58, 0x4D, 0x5D, 0x0C, 0x09, 0x59, 0x18, 0x48 
.db	0x07, 0x13, 0x43, 0x56, 0x16, 0x02, 0x46, 0x17, 0x52, 0x47, 0x57, 0x06, 0x03, 0x53, 0x12, 0x42 
.db	0xA7, 0xB3, 0xE3, 0xF6, 0xB6, 0xA2, 0xE6, 0xB7, 0xF2, 0xE7, 0xF7, 0xA6, 0xA3, 0xF3, 0xB2, 0xE2 
.db	0x25, 0x31, 0x61, 0x74, 0x34, 0x20, 0x64, 0x35, 0x70, 0x65, 0x75, 0x24, 0x21, 0x71, 0x30, 0x60 
.db	0x85, 0x91, 0xC1, 0xD4, 0x94, 0x80, 0xC4, 0x95, 0xD0, 0xC5, 0xD5, 0x84, 0x81, 0xD1, 0x90, 0xC0

sbox_pmt_0:
.db	0xC3, 0xC6, 0xD2, 0x97, 0x87, 0x82, 0x93, 0xC7, 0x96, 0xD3, 0xD7, 0x83, 0xC2, 0xD6, 0x86, 0x92
.db	0xC9, 0xCC, 0xD8, 0x9D, 0x8D, 0x88, 0x99, 0xCD, 0x9C, 0xD9, 0xDD, 0x89, 0xC8, 0xDC, 0x8C, 0x98 
.db	0xE1, 0xE4, 0xF0, 0xB5, 0xA5, 0xA0, 0xB1, 0xE5, 0xB4, 0xF1, 0xF5, 0xA1, 0xE0, 0xF4, 0xA4, 0xB0 
.db	0x6B, 0x6E, 0x7A, 0x3F, 0x2F, 0x2A, 0x3B, 0x6F, 0x3E, 0x7B, 0x7F, 0x2B, 0x6A, 0x7E, 0x2E, 0x3A 
.db	0x4B, 0x4E, 0x5A, 0x1F, 0x0F, 0x0A, 0x1B, 0x4F, 0x1E, 0x5B, 0x5F, 0x0B, 0x4A, 0x5E, 0x0E, 0x1A 
.db	0x41, 0x44, 0x50, 0x15, 0x05, 0x00, 0x11, 0x45, 0x14, 0x51, 0x55, 0x01, 0x40, 0x54, 0x04, 0x10 
.db	0x63, 0x66, 0x72, 0x37, 0x27, 0x22, 0x33, 0x67, 0x36, 0x73, 0x77, 0x23, 0x62, 0x76, 0x26, 0x32 
.db	0xCB, 0xCE, 0xDA, 0x9F, 0x8F, 0x8A, 0x9B, 0xCF, 0x9E, 0xDB, 0xDF, 0x8B, 0xCA, 0xDE, 0x8E, 0x9A 
.db	0x69, 0x6C, 0x78, 0x3D, 0x2D, 0x28, 0x39, 0x6D, 0x3C, 0x79, 0x7D, 0x29, 0x68, 0x7C, 0x2C, 0x38 
.db	0xE3, 0xE6, 0xF2, 0xB7, 0xA7, 0xA2, 0xB3, 0xE7, 0xB6, 0xF3, 0xF7, 0xA3, 0xE2, 0xF6, 0xA6, 0xB2 
.db	0xEB, 0xEE, 0xFA, 0xBF, 0xAF, 0xAA, 0xBB, 0xEF, 0xBE, 0xFB, 0xFF, 0xAB, 0xEA, 0xFE, 0xAE, 0xBA 
.db	0x43, 0x46, 0x52, 0x17, 0x07, 0x02, 0x13, 0x47, 0x16, 0x53, 0x57, 0x03, 0x42, 0x56, 0x06, 0x12 
.db	0xC1, 0xC4, 0xD0, 0x95, 0x85, 0x80, 0x91, 0xC5, 0x94, 0xD1, 0xD5, 0x81, 0xC0, 0xD4, 0x84, 0x90 
.db	0xE9, 0xEC, 0xF8, 0xBD, 0xAD, 0xA8, 0xB9, 0xED, 0xBC, 0xF9, 0xFD, 0xA9, 0xE8, 0xFC, 0xAC, 0xB8 
.db	0x49, 0x4C, 0x58, 0x1D, 0x0D, 0x08, 0x19, 0x4D, 0x1C, 0x59, 0x5D, 0x09, 0x48, 0x5C, 0x0C, 0x18 
.db	0x61, 0x64, 0x70, 0x35, 0x25, 0x20, 0x31, 0x65, 0x34, 0x71, 0x75, 0x21, 0x60, 0x74, 0x24, 0x30

/* I also need a REGULAR SBox to input the key parts that use the SBox (and obviously I can't use the Combined S-P tables 
 * Also, I use a 256 byte SBox because it is easier to access bytes instead of 4-bit nibbles
 */
sbox256:
.db 0xCC, 0xC5, 0xC6, 0xCB, 0xC9, 0xC0, 0xCA, 0xCD, 0xC3, 0xCE, 0xCF, 0xC8, 0xC4, 0xC7, 0xC1, 0xC2
.db 0x5C, 0x55, 0x56, 0x5B, 0x59, 0x50, 0x5A, 0x5D, 0x53, 0x5E, 0x5F, 0x58, 0x54, 0x57, 0x51, 0x52
.db 0x6C, 0x65, 0x66, 0x6B, 0x69, 0x60, 0x6A, 0x6D, 0x63, 0x6E, 0x6F, 0x68, 0x64, 0x67, 0x61, 0x62
.db 0xBC, 0xB5, 0xB6, 0xBB, 0xB9, 0xB0, 0xBA, 0xBD, 0xB3, 0xBE, 0xBF, 0xB8, 0xB4, 0xB7, 0xB1, 0xB2
.db 0x9C, 0x95, 0x96, 0x9B, 0x99, 0x90, 0x9A, 0x9D, 0x93, 0x9E, 0x9F, 0x98, 0x94, 0x97, 0x91, 0x92
.db 0x0C, 0x05, 0x06, 0x0B, 0x09, 0x00, 0x0A, 0x0D, 0x03, 0x0E, 0x0F, 0x08, 0x04, 0x07, 0x01, 0x02
.db 0xAC, 0xA5, 0xA6, 0xAB, 0xA9, 0xA0, 0xAA, 0xAD, 0xA3, 0xAE, 0xAF, 0xA8, 0xA4, 0xA7, 0xA1, 0xA2
.db 0xDC, 0xD5, 0xD6, 0xDB, 0xD9, 0xD0, 0xDA, 0xDD, 0xD3, 0xDE, 0xDF, 0xD8, 0xD4, 0xD7, 0xD1, 0xD2
.db 0x3C, 0x35, 0x36, 0x3B, 0x39, 0x30, 0x3A, 0x3D, 0x33, 0x3E, 0x3F, 0x38, 0x34, 0x37, 0x31, 0x32
.db 0xEC, 0xE5, 0xE6, 0xEB, 0xE9, 0xE0, 0xEA, 0xED, 0xE3, 0xEE, 0xEF, 0xE8, 0xE4, 0xE7, 0xE1, 0xE2
.db 0xFC, 0xF5, 0xF6, 0xFB, 0xF9, 0xF0, 0xFA, 0xFD, 0xF3, 0xFE, 0xFF, 0xF8, 0xF4, 0xF7, 0xF1, 0xF2
.db 0x8C, 0x85, 0x86, 0x8B, 0x89, 0x80, 0x8A, 0x8D, 0x83, 0x8E, 0x8F, 0x88, 0x84, 0x87, 0x81, 0x82
.db 0x4C, 0x45, 0x46, 0x4B, 0x49, 0x40, 0x4A, 0x4D, 0x43, 0x4E, 0x4F, 0x48, 0x44, 0x47, 0x41, 0x42
.db 0x7C, 0x75, 0x76, 0x7B, 0x79, 0x70, 0x7A, 0x7D, 0x73, 0x7E, 0x7F, 0x78, 0x74, 0x77, 0x71, 0x72
.db 0x1C, 0x15, 0x16, 0x1B, 0x19, 0x10, 0x1A, 0x1D, 0x13, 0x1E, 0x1F, 0x18, 0x14, 0x17, 0x11, 0x12
.db 0x2C, 0x25, 0x26, 0x2B, 0x29, 0x20, 0x2A, 0x2D, 0x23, 0x2E, 0x2F, 0x28, 0x24, 0x27, 0x21, 0x22

.org 0x00

/* We store the current state [64 bits] in registers r0 until r7 
   because we only load them once and then only operate on them. */

//BEGIN: load current state with PLAINTEXT values
ldi r16,0x12
ldi r17,0x33
ldi r18,0x0A
ldi r19,0x1B
ldi r20,0xFF
ldi r21,0x90
ldi r22,0xFE
ldi r23,0x01

mov r0,r16
mov r1,r17
mov r2,r18
mov r3,r19
mov r4,r20
mov r5,r21
mov r6,r22
mov r7,r23
//END: load current state with PLAINTEXT values

//BEGIN: Load r8,r9,...,r15,r16,r17 with a key 0x00 s.t. I test faster
ldi r16,0x00
ldi r17,0x00
ldi r18,0x00
ldi r19,0x00
ldi r20,0x00
ldi r21,0x00
ldi r22,0x00
ldi r23,0x00
ldi r24,0x00
ldi r25,0x00

mov r8,r16
mov r9,r17
mov r10,r18
mov r11,r19
mov r12,r20
mov r13,r21
mov r14,r22
mov r15,r23
mov r16,r24
mov r17,r25

//END: Load r8,r9,...,r15,r16,r17 with a key

LOOP_BEGINNING:

/* AddRoundKey: XOR the plaintext with [CARE] the leftmost 64bits of 80-bit key to create the 1st STATE*/

eor r0,r10
eor r1,r11
eor r2,r12
eor r3,r13
eor r4,r14
eor r5,r15
eor r6,r16
eor r7,r17

/* STATE is stored in r0,r1,...,r7 */

/* Do the KEY UPDATE here */



// Question: Is x+x better than 2*x  or than <<? 


/* SBox and PLayer combined in LookupTables
Technique: Load sbox_pmt table address to Z and fetch */

/* CARE: In order to avoid loading to ZL the sbox_pmt_3+sbox_pmt_3 = ldi + add = 2cc,
 * we directly load the value 0x60 = 1cc .
 * One more thing: in order to avoid loading ZH everytime we lookup elsewhere, we start the tables at 
 * address 0x0600 (so .org 0x0300 for word address) and e.g. table 3 starts at 0x0600 and ends at 0x0600+0xFF
 * Now, we only have to change ZL before looking up in the same table. We change ZH only when moving to a different table.
 * Last, in order to avoid changing ZH, we first do all table3 lookups, then all table2 lookups,...
 */

/* Lookup Table 3 */
ldi ZH, 0x06
mov ZL, r0
lpm r16, Z

mov ZL,r4
lpm r20,Z

mov ZL,r1
lpm r25,Z

mov ZL,r5
lpm r29,Z

/* Lookup Table 2 */
ldi ZH, 0x07
mov ZL, r1
lpm r17,Z

mov ZL, r5
lpm r21,Z

mov ZL, r2
lpm r26, Z

mov ZL, r6
/* Now here it looks like we are out of registers [cause r30,r31 are Z]. I have r8...r15 and FORTUNATELY I CAN lpm on them. 
 * We use register8 as register30 and register9 as register31.
 */
lpm r8, Z

/* Lookup Table 1 */
ldi ZH, 0x08
mov ZL, r2
lpm r18,Z

mov ZL, r6
lpm r22, Z

mov ZL,r3
lpm r27,Z

mov ZL,r7
/* r9 instead of r31, as mentioned above */
lpm r9,Z

/* Lookup Table 0 */
ldi ZH, 0x09
mov ZL,r3
lpm r19,Z

mov ZL,r7
lpm r23,Z

mov ZL,r0
lpm r24,Z

mov ZL,r4
lpm r28,Z

/* Now, I no longer need Z=(r30, r31), so move r8, r9 there s.t. I can imediately and/or them in following code */
mov r30,r8
mov r31, r9

/* The results[LOW] are stored in | r16, r17, r18, r19 | r20, r21, r22, r23 | r24, r25, r26, r27 | r28, r29, r30, r31 | */
/* Perform the AND/OR operations to combine to a new state[LOW] */

andi r16,0xC0
andi r17,0x30
andi r18,0x0C
andi r19,0x03

or r16,r17
or r16,r18
or r16,r19

andi r20,0xC0
andi r21,0x30
andi r22,0x0C
andi r23,0x03

or r20,r21
or r20,r22
or r20,r23

andi r24,0xC0
andi r25,0x30
andi r26,0x0C
andi r27,0x03

or r24,r25
or r24,r26
or r24,r27

andi r28,0xC0
andi r29,0x30
andi r30,0x0C
andi r31,0x03

or r28,r29
or r28,r30
or r28,r31

/* The low half of the new state is stored in r16, r20, r24 , r28 
 * and we move them to the unused registers r8, r9 ,r10, r11
 */

 mov r8,r16
 mov r9,r20
 mov r10,r24
 mov r11,r28

 /* Now we are officially out of registers, do the procedure once again [modified for the high state ofc] 
 to calculate the high half of the new state */

 /* Lookup Table 3 */

 ldi ZH,0x06
 mov ZL,r2
 lpm r18,Z

 mov ZL,r6
 lpm r22,Z

 mov ZL,r3
 lpm r27,Z

 mov ZL,r7
 /* Instead of r31, we use r15 */
 lpm r15,Z

 /* Lookup Table 2 */

 ldi ZH,0x07
 mov ZL,r3
 lpm r19,Z

 mov ZL,r7
 lpm r23,Z

 mov ZL,r0
 lpm r24,Z

 mov ZL,r4
 lpm r28,Z

/* Lookup Table 1 */

 ldi ZH,0x08
 mov ZL,r0
 lpm r16,Z

 mov ZL,r4
 lpm r20,Z

 mov ZL,r1
 lpm r25,Z

 mov ZL,r5
 lpm r29,Z

/* Lookup Table 0 */

 ldi ZH,0x09
 mov ZL,r1
 lpm r17,Z

 mov ZL,r5
 lpm r21,Z

 mov ZL,r2
 lpm r26,Z

 mov ZL,r6
 /* Instead of r30, we use r14 */
 /* Although we don't need Z anymore, we avoid doing lpm r30, Z  [to gain 1cc] because it is UNDEFINED
    and I'm kinda afraid - WILL CHECK AGAIN [perhaps only lpm r30,Z+ is undefined] */
 lpm r14,Z

 
/* Now, I no longer need Z=(r30, r31), so move r14, r15 there s.t. I can imediately and/or them in following code */
mov r30,r14
mov r31, r15

/* The results[HIGH]are stored in | r16, r17, r18, r19 | r20, r21, r22, r23 | r24, r25, r26, r27 | r28, r29, r30, r31 | */
/* Perform the AND/OR operations to combine to a new state[HIGH] */

andi r16,0xC0
andi r17,0x30
andi r18,0x0C
andi r19,0x03

or r16,r17
or r16,r18
or r16,r19

andi r20,0xC0
andi r21,0x30
andi r22,0x0C
andi r23,0x03

or r20,r21
or r20,r22
or r20,r23

andi r24,0xC0
andi r25,0x30
andi r26,0x0C
andi r27,0x03

or r24,r25
or r24,r26
or r24,r27

andi r28,0xC0
andi r29,0x30
andi r30,0x0C
andi r31,0x03

or r28,r29
or r28,r30
or r28,r31

/* The high half of the new state is stored in r16, r20, r24 , r28 
 * and we move them to the unused registers r12, r13 ,r14, r15
 */

 mov r12,r16
 mov r13,r20
 mov r14,r24
 mov r15,r28


 /* FINALLY, FULL new state [64 bits] is stored in r8, r9, ... , r15 */
