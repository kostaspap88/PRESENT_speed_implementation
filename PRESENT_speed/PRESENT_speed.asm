/*
 * PRESENT_cipher_speed.asm
 * A speed-oriented implementation of the PRESENT cipher on Atmel AVR microcontroller [ATtiny45]
 * [original paper "PRESENT: AN Ultral Lightweight Block Cipher" by A. Bogdanov et al.]
 *
 *  Created: 17-Feb-13 2:16:47 PM
 *   Authors:
 *		Aram Verstegen, aram.verstegen@gmail.com
 *		Kostas Papagiannopoulos, kostaspap88@gmail.com		  
 *		Radboud University Nijmegen, Kerckhoff's Institute
 *
 *		Speed Optimizations:
 *		<list to be completed>
 */ 

 .include "tn45def.inc"



 
/* Start at a position high in memory, make sure that code doesn't reach it. */
.org 0x0300

/* 
 * Use lookup tables that combine the cipher's SBox and Player.
 *	Originally created and developed by Bo Zhu and Zheng Gong, bo.zhu@uwaterloo.ca, cis.gong@gmail.com
 * [http://cis.sjtu.edu.cn/index.php/Software_Implementation_of_Block_Cipher_PRESENT_for_8-Bit_Platforms]
 */

/* Care: Each .db directive must use an EVEN number (namely 8) of arguments s.t. we don't waste memory
   [.db 0xFF stores 1 byte in 1 word, so we prefer .db 0xFF 0xFF, i.e. 2 bytes in 1 word] */
//Byte address: 0x0600
sbox_pmt_3:
.db	0xF0, 0xB1, 0xB4, 0xE5, 0xE1, 0xA0, 0xE4, 0xF1, 0xA5, 0xF4, 0xF5, 0xE0, 0xB0, 0xB5, 0xA1, 0xA4 
.db	0x72, 0x33, 0x36, 0x67, 0x63, 0x22, 0x66, 0x73, 0x27, 0x76, 0x77, 0x62, 0x32, 0x37, 0x23, 0x26 
.db	0x78, 0x39, 0x3C, 0x6D, 0x69, 0x28, 0x6C, 0x79, 0x2D, 0x7C, 0x7D, 0x68, 0x38, 0x3D, 0x29, 0x2C 
.db	0xDA, 0x9B, 0x9E, 0xCF, 0xCB, 0x8A, 0xCE, 0xDB, 0x8F, 0xDE, 0xDF, 0xCA, 0x9A, 0x9F, 0x8B, 0x8E 
.db	0xD2, 0x93, 0x96, 0xC7, 0xC3, 0x82, 0xC6, 0xD3, 0x87, 0xD6, 0xD7, 0xC2, 0x92, 0x97, 0x83, 0x86
.db	0x50, 0x11, 0x14, 0x45, 0x41, 0x00, 0x44, 0x51, 0x05, 0x54, 0x55, 0x40, 0x10, 0x15, 0x01, 0x04
.db	0xD8, 0x99, 0x9C, 0xCD, 0xC9, 0x88, 0xCC, 0xD9, 0x8D, 0xDC, 0xDD, 0xC8, 0x98, 0x9D, 0x89, 0x8C
.db	0xF2, 0xB3, 0xB6, 0xE7, 0xE3, 0xA2, 0xE6, 0xF3, 0xA7, 0xF6, 0xF7, 0xE2, 0xB2, 0xB7, 0xA3, 0xA6
.db	0x5A, 0x1B, 0x1E, 0x4F, 0x4B, 0x0A, 0x4E, 0x5B, 0x0F, 0x5E, 0x5F, 0x4A, 0x1A, 0x1F, 0x0B, 0x0E
.db	0xF8, 0xB9, 0xBC, 0xED, 0xE9, 0xA8, 0xEC, 0xF9, 0xAD, 0xFC, 0xFD, 0xE8, 0xB8, 0xBD, 0xA9, 0xAC
.db	0xFA, 0xBB, 0xBE, 0xEF, 0xEB, 0xAA, 0xEE, 0xFB, 0xAF, 0xFE, 0xFF, 0xEA, 0xBA, 0xBF, 0xAB, 0xAE 
.db	0xD0, 0x91, 0x94, 0xC5, 0xC1, 0x80, 0xC4, 0xD1, 0x85, 0xD4, 0xD5, 0xC0, 0x90, 0x95, 0x81, 0x84 
.db	0x70, 0x31, 0x34, 0x65, 0x61, 0x20, 0x64, 0x71, 0x25, 0x74, 0x75, 0x60, 0x30, 0x35, 0x21, 0x24 
.db	0x7A, 0x3B, 0x3E, 0x6F, 0x6B, 0x2A, 0x6E, 0x7B, 0x2F, 0x7E, 0x7F, 0x6A, 0x3A, 0x3F, 0x2B, 0x2E 
.db	0x52, 0x13, 0x16, 0x47, 0x43, 0x02, 0x46, 0x53, 0x07, 0x56, 0x57, 0x42, 0x12, 0x17, 0x03, 0x06 
.db	0x58, 0x19, 0x1C, 0x4D, 0x49, 0x08, 0x4C, 0x59, 0x0D, 0x5C, 0x5D, 0x48, 0x18, 0x1D, 0x09, 0x0C

//Byte address: 0x0700
sbox_pmt_2:
.db	0x3C, 0x6C, 0x2D, 0x79, 0x78, 0x28, 0x39, 0x7C, 0x69, 0x3D, 0x7D, 0x38, 0x2C, 0x6D, 0x68, 0x29
.db	0x9C, 0xCC, 0x8D, 0xD9, 0xD8, 0x88, 0x99, 0xDC, 0xC9, 0x9D, 0xDD, 0x98, 0x8C, 0xCD, 0xC8, 0x89 
.db	0x1E, 0x4E, 0x0F, 0x5B, 0x5A, 0x0A, 0x1B, 0x5E, 0x4B, 0x1F, 0x5F, 0x1A, 0x0E, 0x4F, 0x4A, 0x0B 
.db	0xB6, 0xE6, 0xA7, 0xF3, 0xF2, 0xA2, 0xB3, 0xF6, 0xE3, 0xB7, 0xF7, 0xB2, 0xA6, 0xE7, 0xE2, 0xA3 
.db	0xB4, 0xE4, 0xA5, 0xF1, 0xF0, 0xA0, 0xB1, 0xF4, 0xE1, 0xB5, 0xF5, 0xB0, 0xA4, 0xE5, 0xE0, 0xA1 
.db	0x14, 0x44, 0x05, 0x51, 0x50, 0x00, 0x11, 0x54, 0x41, 0x15, 0x55, 0x10, 0x04, 0x45, 0x40, 0x01 
.db	0x36, 0x66, 0x27, 0x73, 0x72, 0x22, 0x33, 0x76, 0x63, 0x37, 0x77, 0x32, 0x26, 0x67, 0x62, 0x23 
.db	0xBC, 0xEC, 0xAD, 0xF9, 0xF8, 0xA8, 0xB9, 0xFC, 0xE9, 0xBD, 0xFD, 0xB8, 0xAC, 0xED, 0xE8, 0xA9 
.db	0x96, 0xC6, 0x87, 0xD3, 0xD2, 0x82, 0x93, 0xD6, 0xC3, 0x97, 0xD7, 0x92, 0x86, 0xC7, 0xC2, 0x83 
.db	0x3E, 0x6E, 0x2F, 0x7B, 0x7A, 0x2A, 0x3B, 0x7E, 0x6B, 0x3F, 0x7F, 0x3A, 0x2E, 0x6F, 0x6A, 0x2B 
.db	0xBE, 0xEE, 0xAF, 0xFB, 0xFA, 0xAA, 0xBB, 0xFE, 0xEB, 0xBF, 0xFF, 0xBA, 0xAE, 0xEF, 0xEA, 0xAB 
.db	0x34, 0x64, 0x25, 0x71, 0x70, 0x20, 0x31, 0x74, 0x61, 0x35, 0x75, 0x30, 0x24, 0x65, 0x60, 0x21 
.db	0x1C, 0x4C, 0x0D, 0x59, 0x58, 0x08, 0x19, 0x5C, 0x49, 0x1D, 0x5D, 0x18, 0x0C, 0x4D, 0x48, 0x09 
.db	0x9E, 0xCE, 0x8F, 0xDB, 0xDA, 0x8A, 0x9B, 0xDE, 0xCB, 0x9F, 0xDF, 0x9A, 0x8E, 0xCF, 0xCA, 0x8B 
.db	0x94, 0xC4, 0x85, 0xD1, 0xD0, 0x80, 0x91, 0xD4, 0xC1, 0x95, 0xD5, 0x90, 0x84, 0xC5, 0xC0, 0x81 
.db	0x16, 0x46, 0x07, 0x53, 0x52, 0x02, 0x13, 0x56, 0x43, 0x17, 0x57, 0x12, 0x06, 0x47, 0x42, 0x03

//Byte address: 0x0800
sbox_pmt_1:
.db	0x0F, 0x1B, 0x4B, 0x5E, 0x1E, 0x0A, 0x4E, 0x1F, 0x5A, 0x4F, 0x5F, 0x0E, 0x0B, 0x5B, 0x1A, 0x4A
.db	0x27, 0x33, 0x63, 0x76, 0x36, 0x22, 0x66, 0x37, 0x72, 0x67, 0x77, 0x26, 0x23, 0x73, 0x32, 0x62 
.db	0x87, 0x93, 0xC3, 0xD6, 0x96, 0x82, 0xC6, 0x97, 0xD2, 0xC7, 0xD7, 0x86, 0x83, 0xD3, 0x92, 0xC2 
.db	0xAD, 0xB9, 0xE9, 0xFC, 0xBC, 0xA8, 0xEC, 0xBD, 0xF8, 0xED, 0xFD, 0xAC, 0xA9, 0xF9, 0xB8, 0xE8 
.db	0x2D, 0x39, 0x69, 0x7C, 0x3C, 0x28, 0x6C, 0x3D, 0x78, 0x6D, 0x7D, 0x2C, 0x29, 0x79, 0x38, 0x68 
.db	0x05, 0x11, 0x41, 0x54, 0x14, 0x00, 0x44, 0x15, 0x50, 0x45, 0x55, 0x04, 0x01, 0x51, 0x10, 0x40 
.db	0x8D, 0x99, 0xC9, 0xDC, 0x9C, 0x88, 0xCC, 0x9D, 0xD8, 0xCD, 0xDD, 0x8C, 0x89, 0xD9, 0x98, 0xC8 
.db	0x2F, 0x3B, 0x6B, 0x7E, 0x3E, 0x2A, 0x6E, 0x3F, 0x7A, 0x6F, 0x7F, 0x2E, 0x2B, 0x7B, 0x3A, 0x6A 
.db	0xA5, 0xB1, 0xE1, 0xF4, 0xB4, 0xA0, 0xE4, 0xB5, 0xF0, 0xE5, 0xF5, 0xA4, 0xA1, 0xF1, 0xB0, 0xE0 
.db	0x8F, 0x9B, 0xCB, 0xDE, 0x9E, 0x8A, 0xCE, 0x9F, 0xDA, 0xCF, 0xDF, 0x8E, 0x8B, 0xDB, 0x9A, 0xCA 
.db	0xAF, 0xBB, 0xEB, 0xFE, 0xBE, 0xAA, 0xEE, 0xBF, 0xFA, 0xEF, 0xFF, 0xAE, 0xAB, 0xFB, 0xBA, 0xEA 
.db	0x0D, 0x19, 0x49, 0x5C, 0x1C, 0x08, 0x4C, 0x1D, 0x58, 0x4D, 0x5D, 0x0C, 0x09, 0x59, 0x18, 0x48 
.db	0x07, 0x13, 0x43, 0x56, 0x16, 0x02, 0x46, 0x17, 0x52, 0x47, 0x57, 0x06, 0x03, 0x53, 0x12, 0x42 
.db	0xA7, 0xB3, 0xE3, 0xF6, 0xB6, 0xA2, 0xE6, 0xB7, 0xF2, 0xE7, 0xF7, 0xA6, 0xA3, 0xF3, 0xB2, 0xE2 
.db	0x25, 0x31, 0x61, 0x74, 0x34, 0x20, 0x64, 0x35, 0x70, 0x65, 0x75, 0x24, 0x21, 0x71, 0x30, 0x60 
.db	0x85, 0x91, 0xC1, 0xD4, 0x94, 0x80, 0xC4, 0x95, 0xD0, 0xC5, 0xD5, 0x84, 0x81, 0xD1, 0x90, 0xC0

//Byte address: 0x0900
sbox_pmt_0:
.db	0xC3, 0xC6, 0xD2, 0x97, 0x87, 0x82, 0x93, 0xC7, 0x96, 0xD3, 0xD7, 0x83, 0xC2, 0xD6, 0x86, 0x92
.db	0xC9, 0xCC, 0xD8, 0x9D, 0x8D, 0x88, 0x99, 0xCD, 0x9C, 0xD9, 0xDD, 0x89, 0xC8, 0xDC, 0x8C, 0x98 
.db	0xE1, 0xE4, 0xF0, 0xB5, 0xA5, 0xA0, 0xB1, 0xE5, 0xB4, 0xF1, 0xF5, 0xA1, 0xE0, 0xF4, 0xA4, 0xB0 
.db	0x6B, 0x6E, 0x7A, 0x3F, 0x2F, 0x2A, 0x3B, 0x6F, 0x3E, 0x7B, 0x7F, 0x2B, 0x6A, 0x7E, 0x2E, 0x3A 
.db	0x4B, 0x4E, 0x5A, 0x1F, 0x0F, 0x0A, 0x1B, 0x4F, 0x1E, 0x5B, 0x5F, 0x0B, 0x4A, 0x5E, 0x0E, 0x1A 
.db	0x41, 0x44, 0x50, 0x15, 0x05, 0x00, 0x11, 0x45, 0x14, 0x51, 0x55, 0x01, 0x40, 0x54, 0x04, 0x10 
.db	0x63, 0x66, 0x72, 0x37, 0x27, 0x22, 0x33, 0x67, 0x36, 0x73, 0x77, 0x23, 0x62, 0x76, 0x26, 0x32 
.db	0xCB, 0xCE, 0xDA, 0x9F, 0x8F, 0x8A, 0x9B, 0xCF, 0x9E, 0xDB, 0xDF, 0x8B, 0xCA, 0xDE, 0x8E, 0x9A 
.db	0x69, 0x6C, 0x78, 0x3D, 0x2D, 0x28, 0x39, 0x6D, 0x3C, 0x79, 0x7D, 0x29, 0x68, 0x7C, 0x2C, 0x38 
.db	0xE3, 0xE6, 0xF2, 0xB7, 0xA7, 0xA2, 0xB3, 0xE7, 0xB6, 0xF3, 0xF7, 0xA3, 0xE2, 0xF6, 0xA6, 0xB2 
.db	0xEB, 0xEE, 0xFA, 0xBF, 0xAF, 0xAA, 0xBB, 0xEF, 0xBE, 0xFB, 0xFF, 0xAB, 0xEA, 0xFE, 0xAE, 0xBA 
.db	0x43, 0x46, 0x52, 0x17, 0x07, 0x02, 0x13, 0x47, 0x16, 0x53, 0x57, 0x03, 0x42, 0x56, 0x06, 0x12 
.db	0xC1, 0xC4, 0xD0, 0x95, 0x85, 0x80, 0x91, 0xC5, 0x94, 0xD1, 0xD5, 0x81, 0xC0, 0xD4, 0x84, 0x90 
.db	0xE9, 0xEC, 0xF8, 0xBD, 0xAD, 0xA8, 0xB9, 0xED, 0xBC, 0xF9, 0xFD, 0xA9, 0xE8, 0xFC, 0xAC, 0xB8 
.db	0x49, 0x4C, 0x58, 0x1D, 0x0D, 0x08, 0x19, 0x4D, 0x1C, 0x59, 0x5D, 0x09, 0x48, 0x5C, 0x0C, 0x18 
.db	0x61, 0x64, 0x70, 0x35, 0x25, 0x20, 0x31, 0x65, 0x34, 0x71, 0x75, 0x21, 0x60, 0x74, 0x24, 0x30

/* I also need a REGULAR SBox to input the key parts that use the SBox (and obviously I can't use the Combined S-P tables 
 * We use a 256 byte SBox because it is easier to access bytes instead of 4-bit nibbles
 * Note: only the first 4 bits are substituted each time e.g. 0x00 becomes 0xC0
 */
 //Byte address: 0x0A00
 
sbox256:
.db 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF
.db 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F
.db 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F
.db 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF
.db 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F
.db 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
.db 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF
.db 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF
.db 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F
.db 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF
.db 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
.db 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F
.db 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F
.db 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F
.db 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F
.db 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F



.org 0x00

/* Start of program. */


//BEGIN: load current state with PLAINTEXT values e.g. 0x00
ldi r16,0x00
ldi r17,0x00
ldi r18,0x00
ldi r19,0x00
ldi r20,0x00
ldi r21,0x00
ldi r22,0x00
ldi r23,0x00

mov r0,r16
mov r1,r17
mov r2,r18
mov r3,r19
mov r4,r20
mov r5,r21
mov r6,r22
mov r7,r23
//END: load current state with PLAINTEXT values

//BEGIN: Load r8,r9,...,r15,r16,r17 with a key 0x00


ldi r16,0x00
ldi r17,0x00
ldi r18,0x00
ldi r19,0x00
ldi r20,0x00
ldi r21,0x00
ldi r22,0x00
ldi r23,0x00
ldi r24,0x00
ldi r25,0x00

mov r8,r16
mov r9,r17
mov r10,r18
mov r11,r19
mov r12,r20
mov r13,r21
mov r14,r22
mov r15,r23
mov r16,r24
mov r17,r25

//END: Load r8,r9,...,r15,r16,r17 with a key
//End of initialization phase

//BEGIN: start counter
ldi r20,0x00

//END: start counter

/* Memory MSB:LSB */

LOOP_BEGINNING:

/* AddRoundKey: XOR the plaintext with [CARE] the leftmost 64bits of 80-bit key to create the 1st STATE*/


eor r0,r17
eor r1,r16
eor r2,r15
eor r3,r14
eor r4,r13
eor r5,r12
eor r6,r11
eor r7,r10
/* XORED STATE is in r0,r1,...,r7 */

/* Do the KEY UPDATE and counter increase here, key is stored in r8,r9,...,r17 */

/* Do the XOR counter first s.t. it spans only one byte,
 * because bits 15,16,17,18,19 are bits 34,35,36,37,38 which span only one byte in register r12
 */

 inc r20 /* Increase counter */ 

 /*key XOR counter. Instead of shifts we could also precompute shifted values and store them in 
  *lookup table
  */
 lsl r20
 lsl r20
 eor r12,r20
 lsr r20
 lsr r20

/* 61 rotations to left = 19 rotations to the right = 2*(8bit moves) + 3 bit rotation right */

/* 2*8 bit rotation is done easily with mov */
mov r18,r8
mov r19,r9
/* key is stored in r10, r11, ... ,r19 */
/* Perform 3 rotations to the right */

/* 1st rotation */
/* clear r9 which will work as a temp */
eor r9,r9

lsr r19
ror r18
ror r17
ror r16
ror r15
ror r14
ror r13
ror r12
ror r11
ror r10

ror r9
or r19,r9

/* 2nd rotation - keep the thing unrolled :D */
eor r9,r9

lsr r19
ror r18
ror r17
ror r16
ror r15
ror r14
ror r13
ror r12
ror r11
ror r10

ror r9
or r19,r9 // think about addc and not use r9

/* 3rd rotation */

eor r9,r9

lsr r19
ror r18
ror r17
ror r16
ror r15
ror r14
ror r13
ror r12
ror r11
ror r10

ror r9
or r19,r9



/* SBox on key bits 76,77,78,79 i.e. high part of register r19 */
ldi ZH, 0x0A
mov ZL,r19
lpm r19,Z


/* key is stored in r10, r11, ... ,r19. I should probably move it back to r8,r9,r10,....,r17 */
mov r8,r10
mov r9,r11
mov r10,r12
mov r11,r13
mov r12,r14
mov r13,r15
mov r14,r16
mov r15,r17
mov r16,r18
mov r17,r19



/* Finally, updated key is stored in r8,r9,r10,...,r17 */


/* SBox and PLayer combined in LookupTables
Technique: Load sbox_pmt table address to Z and fetch */

 
/* We directly load the value 0x60 = 1cc .
 * One more thing: in order to avoid loading ZH everytime we lookup elsewhere, we start the tables at 
 * address 0x0600 (so .org 0x0300 for word address) and e.g. table 3 starts at 0x0600 and ends at 0x0600+0xFF
 * Now, we only have to change ZL before looking up in the same table. We change ZH only when moving to a different table.
 * Last, in order to avoid changing ZH, we first do as many lookups from the same table as possible.
 * With the current number of available registers, we can only combine ZH for two or tables
 */

/* cipher 0 */
ldi ZH, 0x06
mov ZL, r0
lpm r21, Z
andi r21,0xC0

/* cipher 1 - use the ZH=0x06 */ 
mov ZL, r4
lpm r22, Z
andi r22,0xC0

/* cipher 0 */
ldi ZH, 0x07
mov ZL, r1
lpm r23, Z
andi r23,0x30
or r21,r23

/* cipher 1 */
mov ZL, r5
lpm r23, Z
andi r23,0x30
or r22,r23

/* cipher 0 */
ldi ZH, 0x08
mov ZL, r2
lpm r23, Z
andi r23,0x0C
or r21,r23

/* cipher 1 */
mov ZL, r6
lpm r23, Z
andi r23,0x0C
or r22,r23

/* cipher 0 */
ldi ZH, 0x09
mov ZL, r3
lpm r23, Z
andi r23,0x03
or r21,r23

/* cipher 1 */
mov ZL, r7
lpm r23, Z
andi r23,0x03
or r22,r23

/* cipher0 in r21, cipher1 in r22 */
/* We are moving to the group cipher2,cipher3 but we still use the fact that ZH=0x09 */

/* cipher 2 */
mov ZL,r0
lpm r23,Z
andi r23,0xC0

/* cipher 3 */
mov ZL,r4
lpm r24,Z
andi r24,0xC0

/* cipher 2 */
ldi ZH,0x06
mov ZL,r1
lpm r25,Z
andi r25,0x30
or r23,r25

/* cipher 3 */
mov ZL,r5
lpm r25,Z
andi r25,0x30
or r24,r25

/* cipher 2 */
ldi ZH,0x07
mov ZL,r2
lpm r25,Z
andi r25,0x0C
or r23,r25

/* cipher 3 */
mov ZL,r6
lpm r25,Z
andi r25,0x0C
or r24,r25

/* cipher 2 */
ldi ZH,0x08
mov ZL,r3
lpm r25,Z
andi r25,0x03
or r23,r25

/* cipher 3 */
mov ZL,r7
lpm r25,Z
andi r25,0x03
or r24,r25

/* cipher2,3 stored in r23, r24 */
/* We move to cipher 4 and cipher 5 but we still use ZH=0x08 */

/* cipher 4 */
mov ZL,r0
lpm r25,Z
andi r25,0xC0

/* cipher 5 */
mov ZL,r4
lpm r26,Z
andi r26,0xC0

/* cipher 4 */
ldi ZH,0x09
mov ZL,r1
lpm r27,Z
andi r27,0x30
or r25,r27

/* cipher 5 */
mov ZL,r5
lpm r27,Z
andi r27,0x30
or r26,r27

/* cipher 4 */
ldi ZH,0x06
mov ZL,r2
lpm r27,Z
andi r27,0x0C
or r25,r27

/* cipher 5 */
mov ZL,r6
lpm r27,Z
andi r27,0x0C
or r26,r27

/* cipher 4 */
ldi ZH,0x07
mov ZL,r3
lpm r27,Z
andi r27,0x03
or r25,r27

/* cipher 5 */
mov ZL,r7
lpm r27,Z
andi r27,0x03
or r26,r27

/* cipher 4,5 in registers r25,r26 . We continue to cipher 6,7 using ZH=0x07 */

/* cipher 6 */
mov ZL,r0
lpm r27,Z
andi r27,0xC0

/* cipher 7 */
mov ZL,r4
lpm r28,Z
andi r28,0xC0

/* cipher 6 */
ldi ZH,0x08
mov ZL,r1
lpm r29,Z
andi r29,0x30
or r27,r29

/* cipher 7 */
mov ZL,r5
lpm r29,Z
andi r29,0x30
or r28,r29

/* cipher 6 */
ldi ZH,0x09
mov ZL,r2
lpm r29,Z
andi r29,0x0C
or r27,r29

/* cipher 7 */
mov ZL,r6
lpm r29,Z
andi r29,0x0C
or r28,r29

/* cipher 6 */
ldi ZH,0x06
mov ZL,r3
lpm r29,Z
andi r29,0x03
or r27,r29

/* cipher 7 */
mov ZL,r7
lpm r29,Z
andi r29,0x03
or r28,r29




 /* FINALLY, FULL new state [64 bits] is stored in r21, r22, ... , r28 */

 /* Move the new state back to r0,r1,...,r7 */

 mov r0,r21
 mov r1,r22
 mov r2,r23
 mov r3,r24
 mov r4,r25
 mov r5,r26
 mov r6,r27
 mov r7,r28
 


 /* check if counter reached 31 */
 cpi r20,0x1F
 brne ONE_MORE_ROUND

 END:

eor r0,r17
eor r1,r16
eor r2,r15
eor r3,r14
eor r4,r13
eor r5,r12
eor r6,r11
eor r7,r10 
//result in r0, r1, ... ,r7
 
 //WE REACHED THE END of the program
 //DO NOT CONTINUE FURTHER

 ONE_MORE_ROUND:
 rjmp LOOP_BEGINNING

 //REMEMBER: IT MUST NOT continue execution in the lookup tables! Go Back to start (or STOP the program)